package gov.dwp.utilities.crypto;

import com.fasterxml.jackson.core.SerializableString;
import com.fasterxml.jackson.core.io.CharacterEscapes;
import com.fasterxml.jackson.databind.ObjectMapper;
import gov.dwp.utilities.logging.DwpEncodedLogger;
import org.apache.log4j.Logger;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SealedObject;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.InvalidParameterException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;

public class SecureStrings {
    private static final Logger LOGGER = DwpEncodedLogger.getLogger(SecureStrings.class.getName());
    private Cipher cipherEncrypt = null;
    private Cipher cipherDecrypt = null;

    /**
     * Default constructor.
     * Assumes AES encryption, generates a key and sets up the internal ciphers
     */
    public SecureStrings() {
        try {
            initialiseCiphers("AES");
        } catch (NoSuchAlgorithmException e) {
            LOGGER.error(String.format("Error initialiseCiphers %s", e.getMessage()));
            LOGGER.debug(e);
        }
    }

    /**
     * Overloaded constructor
     * Takes in crypto Type, generates a key and sets up the internal ciphers
     *
     * @param cryptoType a string to match the cryptotype used for key generation and cipher generation
     * @throws NoSuchAlgorithmException - if the input string is not a valid crypto type.
     */
    public SecureStrings(String cryptoType) throws NoSuchAlgorithmException {
        initialiseCiphers(cryptoType);
    }

    /**
     * initialiseCiphers
     * Takes in crypto Type, generates a key and sets up the internal ciphers
     *
     * @param cryptoType a string to match the cryptotype used for key generation and cipher generation
     * @throws NoSuchAlgorithmException - if the input string is not a valid crypto type.
     */
    private void initialiseCiphers(String cryptoType) throws NoSuchAlgorithmException {
        if ((null == cipherEncrypt) || (null == cipherDecrypt)) {
            try {
                Key tempKey = KeyGenerator.getInstance(cryptoType).generateKey();
                cipherEncrypt = Cipher.getInstance(cryptoType);
                cipherDecrypt = Cipher.getInstance(cryptoType);
                cipherEncrypt.init(Cipher.ENCRYPT_MODE, tempKey);
                cipherDecrypt.init(Cipher.DECRYPT_MODE, tempKey);
            } catch (NoSuchPaddingException | InvalidKeyException e) {
                LOGGER.error(String.format("Error initialiseCiphers object %s", e.getMessage()));
                LOGGER.debug(e);
            }
        }
    }

    /**
     * sealString
     * Takes a string and seals it within a SealedObject using the auto-generated ciphers.
     *
     * @param input the string to encapsulate within the returned SealedObject
     * @return SealedObject Object containing encrypted input, null on error
     */
    public SealedObject sealString(String input) {
        SealedObject returnValue = null;
        try {
            returnValue = new SealedObject(input, cipherEncrypt);
        } catch (IOException | IllegalBlockSizeException e) {
            LOGGER.error(String.format("Error setting input : %s", e.getMessage()));
            LOGGER.debug(e);
        }
        return returnValue;
    }

    /**
     * revealString
     * Uses the auto generated ciphers to retrieve a string from the SealedObject.
     *
     * @param inputObject object containing a string to return.
     *                    For success, must be generated by a call to sealString in the same SecureStrings instance.
     * @return String, null on error.
     */
    public String revealString(SealedObject inputObject) {
        if (null != inputObject) try {
            return (String) inputObject.getObject(cipherDecrypt); //using cast to allow for null string input
        } catch (IOException | BadPaddingException | IllegalBlockSizeException | ClassNotFoundException e) {
            LOGGER.error(String.format("Error getting string : %s", e.getMessage()));
            LOGGER.debug(e);
        }
        return null;
    }

    public static <T> T escapedJSONObjectFromString(String inputString, Class<T> type) throws IOException {
        T returnValue;
        if (inputString != null && inputString.trim().length() != 0) {
            final CharacterEscapes jsonCharacterEscapes = generateJSONCharacterEscapes();
            final ObjectMapper objectMapper = new ObjectMapper();
            objectMapper.getFactory().setCharacterEscapes(jsonCharacterEscapes);
            returnValue = objectMapper.readValue(inputString, type);
        } else {
            throw new InvalidParameterException("A JSON payload must be specified");
        }
        return returnValue;
    }

    private static CharacterEscapes generateJSONCharacterEscapes() {
        return new CharacterEscapes() {
            private static final long serialVersionUID = 11L;

            @Override
            public int[] getEscapeCodesForAscii() {
                return standardAsciiEscapesForJSON();
            }

            @Override
            public SerializableString getEscapeSequence(final int ch) {
                return null;
            }
        };
    }
}