package gov.dwp.utilities.crypto;

import gov.dwp.utilities.logging.DwpEncodedLogger;
import org.apache.log4j.Logger;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SealedObject;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;

public class SecureStrings {
    private Cipher cipherEncrypt = null;
    private Cipher cipherDecrypt = null;

    /** For logging */
    private static final Logger LOGGER = DwpEncodedLogger.getLogger(SecureStrings.class.getName());


    /**
     * Default constructor.
     * Assumes AES encryption, generates a key and sets up the internal ciphers
     */
    public SecureStrings(){
        try {
            initialiseCiphers("AES");
        } catch (NoSuchAlgorithmException e) {
            LOGGER.error(String.format("Error initialiseCiphers %s", e.getMessage()));
            LOGGER.debug(e);
        }
    }

    /**
     * Overloaded constructor
     * Takes in crypto Type, generates a key and sets up the internal ciphers
     * @param cryptoType a string to match the cryptotype used for key generation and cipher generation
     * @throws NoSuchAlgorithmException - if the input string is not a valid crypto type.
     *
     */
    public SecureStrings(String cryptoType) throws NoSuchAlgorithmException {
        initialiseCiphers(cryptoType);
    }

    /**
     * initialiseCiphers
     * Takes in crypto Type, generates a key and sets up the internal ciphers
     * @param cryptoType a string to match the cryptotype used for key generation and cipher generation
     * @throws NoSuchAlgorithmException - if the input string is not a valid crypto type.
     */
    private void initialiseCiphers(String cryptoType) throws NoSuchAlgorithmException {
        if ((null == cipherEncrypt) || (null == cipherDecrypt)) {
            try {
                Key tempKey = KeyGenerator.getInstance(cryptoType).generateKey();
                cipherEncrypt = Cipher.getInstance(cryptoType);
                cipherDecrypt = Cipher.getInstance(cryptoType);
                cipherEncrypt.init(Cipher.ENCRYPT_MODE, tempKey);
                cipherDecrypt.init(Cipher.DECRYPT_MODE, tempKey);
            } catch (NoSuchPaddingException | InvalidKeyException e) {
                LOGGER.error(String.format("Error initialiseCiphers object %s", e.getMessage()));
                LOGGER.debug(e);
            }
        }
    }

    /**
     * sealString
     * Takes a string and seals it within a SealedObject using the auto-generated ciphers.
     *
     * @param input the string to encapsulate within the returned SealedObject
     * @return SealedObject Object containing encrypted input, null on error
     */
    public SealedObject sealString(String input){
        SealedObject returnValue = null;
        try {
            returnValue = new SealedObject(input, cipherEncrypt);
        } catch (IOException | IllegalBlockSizeException e) {
            LOGGER.error(String.format("Error setting input : %s", e.getMessage()));
            LOGGER.debug(e);
        }
        return returnValue;
    }

    /**
     * revealString
     * Uses the auto generated ciphers to retrieve a string from the SealedObject.
     * @param inputObject object containing a string to return.
     *                    For success, must be generated by a call to sealString in the same SecureStrings instance.
     * @return String, null on error.
     */
    public String revealString(SealedObject inputObject) {
        if (null != inputObject) try {
            return inputObject.getObject(cipherDecrypt).toString();
        } catch (IOException | BadPaddingException | IllegalBlockSizeException | ClassNotFoundException e) {
            LOGGER.error(String.format("Error getting string : %s", e.getMessage()));
            LOGGER.debug(e);
        }
        return null;
    }
}